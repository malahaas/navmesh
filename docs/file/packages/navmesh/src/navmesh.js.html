<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">packages/navmesh/src/navmesh.js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-injected-style.css"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#navmesh-src">navmesh/src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/navmesh/src/navmesh.js~NavMesh.html">NavMesh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/navmesh/src/navpoly.js~NavPoly.html">NavPoly</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#navmesh-src-math">navmesh/src/math</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/navmesh/src/math/line.js~Line.html">Line</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/navmesh/src/math/polygon.js~Polygon.html">Polygon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/navmesh/src/math/vector-2.js~Vector2.html">Vector2</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#phaser-navmesh-src">phaser-navmesh/src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/phaser-navmesh/src/phaser-navmesh-plugin.js~PhaserNavMeshPlugin.html">PhaserNavMeshPlugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/phaser-navmesh/src/phaser-navmesh.js~PhaserNavMesh.html">PhaserNavMesh</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#phaser2-navmesh-src">phaser2-navmesh/src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/phaser2-navmesh/src/phaser2-navmesh-plugin.js~Phaser2NavMeshPlugin.html">Phaser2NavMeshPlugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/packages/phaser2-navmesh/src/phaser2-navmesh.js~Phaser2NavMesh.html">Phaser2NavMesh</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">packages/navmesh/src/navmesh.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import jsastar from &quot;javascript-astar&quot;;
import NavPoly from &quot;./navpoly&quot;;
import NavGraph from &quot;./navgraph&quot;;
import Channel from &quot;./channel&quot;;
import { angleDifference, areCollinear, clamp } from &quot;./utils&quot;;
import Vector2 from &quot;./math/vector-2&quot;;
import Line from &quot;./math/line&quot;;
import Polygon from &quot;./math/polygon&quot;;

/**
 * The workhorse that represents a navigation mesh built from a series of polygons. Once built, the
 * mesh can be asked for a path from one point to another point. Some internal terminology usage:
 * - neighbor: a polygon that shares part of an edge with another polygon
 * - portal: when two neighbor&apos;s have edges that overlap, the portal is the overlapping line segment
 * - channel: the path of polygons from starting point to end point
 * - pull the string: run the funnel algorithm on the channel so that the path hugs the edges of the
 *   channel. Equivalent to having a string snaking through a hallway and then pulling it taut.
 *
 * @class NavMesh
 */
export default class NavMesh {
  /**
   * Creates an instance of NavMesh.
   * @param {object[][]} meshPolygonPoints Array where each element is an array of point-like
   * objects that defines a polygon.
   * @param {number} [meshShrinkAmount=0] The amount (in pixels) that the navmesh has been
   * shrunk around obstacles (a.k.a the amount obstacles have been expanded)
   * @memberof NavMesh
   */
  constructor(meshPolygonPoints, meshShrinkAmount = 0) {
    this._meshShrinkAmount = meshShrinkAmount;

    const newPolys = meshPolygonPoints.map(polyPoints =&gt; {
      const vectors = polyPoints.map(p =&gt; new Vector2(p.x, p.y));
      return new Polygon(vectors);
    });

    this._navPolygons = newPolys.map((polygon, i) =&gt; new NavPoly(i, polygon));

    this._calculateNeighbors();

    // Astar graph of connections between polygons
    this._graph = new NavGraph(this._navPolygons);
  }

  /**
   * Get the NavPolys that are in this navmesh.
   *
   * @returns {NavPoly[]}
   * @memberof NavMesh
   */
  getPolygons() {
    return this._navPolygons;
  }

  /**
   * Cleanup method to remove references.
   *
   * @memberof NavMesh
   */
  destroy() {
    this._graph.destroy();
    for (const poly of this._navPolygons) poly.destroy();
    this._navPolygons = [];
  }

  /**
   * Find a path from the start point to the end point using this nav mesh.
   *
   * @param {object} startPoint A point-like object in the form {x, y}
   * @param {object} endPoint A point-like object in the form {x, y}
   * @returns {Vector2[]|null} An array of points if a path is found, or null if no path
   *
   * @memberof NavMesh
   */
  findPath(startPoint, endPoint) {
    let startPoly = null;
    let endPoly = null;
    let startDistance = Number.MAX_VALUE;
    let endDistance = Number.MAX_VALUE;
    let d, r;
    const startVector = new Vector2(startPoint.x, startPoint.y);
    const endVector = new Vector2(endPoint.x, endPoint.y);

    // Find the closest poly for the starting and ending point
    for (const navPoly of this._navPolygons) {
      r = navPoly.boundingRadius;
      // Start
      d = navPoly.centroid.distance(startVector);
      if (d &lt;= startDistance &amp;&amp; d &lt;= r &amp;&amp; navPoly.contains(startVector)) {
        startPoly = navPoly;
        startDistance = d;
      }
      // End
      d = navPoly.centroid.distance(endVector);
      if (d &lt;= endDistance &amp;&amp; d &lt;= r &amp;&amp; navPoly.contains(endVector)) {
        endPoly = navPoly;
        endDistance = d;
      }
    }

    // If the end point wasn&apos;t inside a polygon, run a more liberal check that allows a point
    // to be within meshShrinkAmount radius of a polygon
    if (!endPoly &amp;&amp; this._meshShrinkAmount &gt; 0) {
      for (const navPoly of this._navPolygons) {
        r = navPoly.boundingRadius + this._meshShrinkAmount;
        d = navPoly.centroid.distance(endVector);
        if (d &lt;= r) {
          const { distance } = this._projectPointToPolygon(endVector, navPoly);
          if (distance &lt;= this._meshShrinkAmount &amp;&amp; distance &lt; endDistance) {
            endPoly = navPoly;
            endDistance = distance;
          }
        }
      }
    }

    // No matching polygons locations for the end, so no path found
    // because start point is valid normally, check end point first
    if (!endPoly) return null;

    // Same check as above, but for the start point
    if (!startPoly &amp;&amp; this._meshShrinkAmount &gt; 0) {
      for (const navPoly of this._navPolygons) {
        // Check if point is within bounding circle to avoid extra projection calculations
        r = navPoly.boundingRadius + this._meshShrinkAmount;
        d = navPoly.centroid.distance(startVector);
        if (d &lt;= r) {
          // Check if projected point is within range of a polgyon and is closer than the
          // previous point
          const { distance } = this._projectPointToPolygon(startVector, navPoly);
          if (distance &lt;= this._meshShrinkAmount &amp;&amp; distance &lt; startDistance) {
            startPoly = navPoly;
            startDistance = distance;
          }
        }
      }
    }

    // No matching polygons locations for the start, so no path found
    if (!startPoly) return null;

    // If the start and end polygons are the same, return a direct path
    if (startPoly === endPoly) return [startVector, endVector];

    // Search!
    const astarPath = jsastar.astar.search(this._graph, startPoly, endPoly, {
      heuristic: this._graph.navHeuristic
    });

    // While the start and end polygons may be valid, no path between them
    if (astarPath.length === 0) return null;

    // jsastar drops the first point from the path, but the funnel algorithm needs it
    astarPath.unshift(startPoly);

    // We have a path, so now time for the funnel algorithm
    const channel = new Channel();
    channel.push(startVector);
    for (let i = 0; i &lt; astarPath.length - 1; i++) {
      const navPolygon = astarPath[i];
      const nextNavPolygon = astarPath[i + 1];

      // Find the portal
      let portal = null;
      for (let i = 0; i &lt; navPolygon.neighbors.length; i++) {
        if (navPolygon.neighbors[i].id === nextNavPolygon.id) {
          portal = navPolygon.portals[i];
        }
      }

      // Push the portal vertices into the channel
      channel.push(portal.start, portal.end);
    }
    channel.push(endVector);

    // Pull a string along the channel to run the funnel
    channel.stringPull();

    // Clone path, excluding duplicates
    let lastPoint = null;
    const phaserPath = [];
    for (const p of channel.path) {
      const newPoint = p.clone();
      if (!lastPoint || !newPoint.equals(lastPoint)) phaserPath.push(newPoint);
      lastPoint = newPoint;
    }

    return phaserPath;
  }

  _calculateNeighbors() {
    // Fill out the neighbor information for each navpoly
    for (let i = 0; i &lt; this._navPolygons.length; i++) {
      const navPoly = this._navPolygons[i];

      for (let j = i + 1; j &lt; this._navPolygons.length; j++) {
        const otherNavPoly = this._navPolygons[j];

        // Check if the other navpoly is within range to touch
        const d = navPoly.centroid.distance(otherNavPoly.centroid);
        if (d &gt; navPoly.boundingRadius + otherNavPoly.boundingRadius) continue;

        // The are in range, so check each edge pairing
        for (const edge of navPoly.edges) {
          for (const otherEdge of otherNavPoly.edges) {
            // If edges aren&apos;t collinear, not an option for connecting navpolys
            if (!areCollinear(edge, otherEdge)) continue;

            // If they are collinear, check if they overlap
            const overlap = this._getSegmentOverlap(edge, otherEdge);
            if (!overlap) continue;

            // Connections are symmetric!
            navPoly.neighbors.push(otherNavPoly);
            otherNavPoly.neighbors.push(navPoly);

            // Calculate the portal between the two polygons - this needs to be in
            // counter-clockwise order, relative to each polygon
            const [p1, p2] = overlap;
            let edgeStartAngle = navPoly.centroid.angle(edge.start);
            let a1 = navPoly.centroid.angle(overlap[0]);
            let a2 = navPoly.centroid.angle(overlap[1]);
            let d1 = angleDifference(edgeStartAngle, a1);
            let d2 = angleDifference(edgeStartAngle, a2);
            if (d1 &lt; d2) {
              navPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));
            } else {
              navPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));
            }

            edgeStartAngle = otherNavPoly.centroid.angle(otherEdge.start);
            a1 = otherNavPoly.centroid.angle(overlap[0]);
            a2 = otherNavPoly.centroid.angle(overlap[1]);
            d1 = angleDifference(edgeStartAngle, a1);
            d2 = angleDifference(edgeStartAngle, a2);
            if (d1 &lt; d2) {
              otherNavPoly.portals.push(new Line(p1.x, p1.y, p2.x, p2.y));
            } else {
              otherNavPoly.portals.push(new Line(p2.x, p2.y, p1.x, p1.y));
            }

            // Two convex polygons shouldn&apos;t be connected more than once! (Unless
            // there are unnecessary vertices...)
          }
        }
      }
    }
  }

  // Check two collinear line segments to see if they overlap by sorting the points.
  // Algorithm source: http://stackoverflow.com/a/17152247
  _getSegmentOverlap(line1, line2) {
    const points = [
      { line: line1, point: line1.start },
      { line: line1, point: line1.end },
      { line: line2, point: line2.start },
      { line: line2, point: line2.end }
    ];
    points.sort(function(a, b) {
      if (a.point.x &lt; b.point.x) return -1;
      else if (a.point.x &gt; b.point.x) return 1;
      else {
        if (a.point.y &lt; b.point.y) return -1;
        else if (a.point.y &gt; b.point.y) return 1;
        else return 0;
      }
    });
    // If the first two points in the array come from the same line, no overlap
    const noOverlap = points[0].line === points[1].line;
    // If the two middle points in the array are the same coordinates, then there is a
    // single point of overlap.
    const singlePointOverlap = points[1].point.equals(points[2].point);
    if (noOverlap || singlePointOverlap) return null;
    else return [points[1].point, points[2].point];
  }

  /**
   * Project a point onto a polygon in the shortest distance possible.
   *
   * @param {Phaser.Point} point The point to project
   * @param {NavPoly} navPoly The navigation polygon to test against
   * @returns {{point: Phaser.Point, distance: number}}
   *
   * @private
   * @memberof NavMesh
   */
  _projectPointToPolygon(point, navPoly) {
    let closestProjection = null;
    let closestDistance = Number.MAX_VALUE;
    for (const edge of navPoly.edges) {
      const projectedPoint = this._projectPointToEdge(point, edge);
      const d = point.distance(projectedPoint);
      if (closestProjection === null || d &lt; closestDistance) {
        closestDistance = d;
        closestProjection = projectedPoint;
      }
    }
    return { point: closestProjection, distance: closestDistance };
  }

  _distanceSquared(a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    return dx * dx + dy * dy;
  }

  // Project a point onto a line segment
  // JS Source: http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
  _projectPointToEdge(point, line) {
    const a = line.start;
    const b = line.end;
    // Consider the parametric equation for the edge&apos;s line, p = a + t (b - a). We want to find
    // where our point lies on the line by solving for t:
    //  t = [(p-a) . (b-a)] / |b-a|^2
    const l2 = this._distanceSquared(a, b);
    let t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / l2;
    // We clamp t from [0,1] to handle points outside the segment vw.
    t = clamp(t, 0, 1);
    // Project onto the segment
    const p = new Vector2(a.x + t * (b.x - a.x), a.y + t * (b.y - a.y));
    return p;
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
